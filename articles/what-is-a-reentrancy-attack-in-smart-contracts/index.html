<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><title>What Is a Reentrancy Attack in Smart Contracts? - PulseGeek</title><meta name="description" content="Learn how reentrancy attacks work in smart contracts, why they break invariants, and how to prevent them with patterns, guards, audits, and tooling." /><meta name="author" content="Rhea Kavinsky" /><link rel="canonical" href="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts" /><link rel="apple-touch-icon" sizes="180x180" href="https://pulsegeek.com/apple-touch-icon.png" /><link rel="icon" type="image/png" sizes="32x32" href="https://pulsegeek.com/favicon-32x32.png" /><link rel="icon" type="image/png" sizes="16x16" href="https://pulsegeek.com/favicon-16x16.png" /><link rel="manifest" href="https://pulsegeek.com/site.webmanifest" /><link rel="alternate" type="application/rss+xml" title="PulseGeek RSS feed" href="https://pulsegeek.com/rss.xml" /><link rel="alternate" type="application/atom+xml" title="PulseGeek Atom feed" href="https://pulsegeek.com/atom.xml" /><link rel="alternate" type="application/feed+json" title="PulseGeek JSON feed" href="https://pulsegeek.com/feed.json" /><meta property="og:title" content="What Is a Reentrancy Attack in Smart Contracts?" /><meta property="og:type" content="article" /><meta property="og:url" content="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts" /><meta property="og:image" content="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero.webp" /><meta property="og:description" content="Learn how reentrancy attacks work in smart contracts, why they break invariants, and how to prevent them with patterns, guards, audits, and tooling." /><meta property="og:site_name" content="PulseGeek" /><meta property="og:locale" content="en_US" /><meta property="article:author" content="Rhea Kavinsky" /><meta property="article:publisher" content="PulseGeek" /><meta property="article:published_time" content="2025-10-12T04:02:00.0000000" /><meta property="article:modified_time" content="2025-09-10T05:49:45.2688571" /><meta property="article:section" content="Technology / Blockchain / Smart Contract Guides" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:title" content="What Is a Reentrancy Attack in Smart Contracts?" /><meta name="twitter:description" content="Learn how reentrancy attacks work in smart contracts, why they break invariants, and how to prevent them with patterns, guards, audits, and tooling." /><meta name="twitter:image" content="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero.webp" /><meta name="twitter:label1" content="Author" /><meta name="twitter:data1" content="Rhea Kavinsky" /><script type="application/ld+json"> {"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts#article","headline":"What Is a Reentrancy Attack in Smart Contracts?","description":"Learn how reentrancy attacks work in smart contracts, why they break invariants, and how to prevent them with patterns, guards, audits, and tooling.","image":"https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero.webp","author":{"@type":"Person","@id":"https://pulsegeek.com/authors/rhea-kavinsky#author","name":"Rhea Kavinsky","url":"https://pulsegeek.com/authors/rhea-kavinsky"},"publisher":{"@id":"https://pulsegeek.com#organization"},"datePublished":"2025-10-12T04:02:00-05:00","dateModified":"2025-09-10T05:49:45.2688571-05:00","mainEntityOfPage":"https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts","wordCount":"1714","inLanguage":"en-US"},{"@type":"Person","@id":"https://pulsegeek.com/authors/rhea-kavinsky#author","name":"Rhea Kavinsky","url":"https://pulsegeek.com/authors/rhea-kavinsky"},{"@type":"Organization","@id":"https://pulsegeek.com#organization","url":"https://pulsegeek.com","name":"PulseGeek","logo":{"@type":"ImageObject","url":"https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero.webp"}},{"@type":"WebSite","@id":"https://pulsegeek.com#website","url":"https://pulsegeek.com","name":"PulseGeek"},{"@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://pulsegeek.com"},{"@type":"ListItem","position":2,"name":"Technology / Blockchain / Smart Contract Guides","item":"https://pulsegeek.com/technology / blockchain / smart contract guides"},{"@type":"ListItem","position":3,"name":"What Is a Reentrancy Attack in Smart Contracts?","item":"https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts"}]}]} </script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KN2EBXS37E"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KN2EBXS37E'); </script><link href="https://pulsegeek.com/css/pico.green.min.css" rel="stylesheet" /><link href="https://pulsegeek.com/css/site.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container container-narrow"><nav><ul><li><a href="https://pulsegeek.com/" class="brand" aria-label="PulseGeek home"><img src="https://pulsegeek.com/images/logo.png" srcset="https://pulsegeek.com/images/logo.png 1x, https://pulsegeek.com/images/logo@2x.png 2x" alt="PulseGeek" width="308" height="64" class="brand-logo" decoding="async" fetchpriority="high"></a></li></ul><ul><li><a href="https://pulsegeek.com/technology/">Technology</a></li></ul></nav></div></header><main class="container"><nav aria-label="Breadcrumb" class="breadcrumb"><ol><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><a href="https://pulsegeek.com/technology/" title="Technology">Technology</a></li><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><span>Blockchain</span></li></ol></nav><div class="share-buttons" aria-label="Share this article"><span>Share:</span><a class="share-btn x" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fwhat-is-a-reentrancy-attack-in-smart-contracts&amp;text=What%20Is%20a%20Reentrancy%20Attack%20in%20Smart%20Contracts%3F%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on X / Twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M357.2 48L427.8 48 273.6 224.2 455 464 313 464 201.7 318.6 74.5 464 3.8 464 168.7 275.5-5.2 48 140.4 48 240.9 180.9 357.2 48zM332.4 421.8l39.1 0-252.4-333.8-42 0 255.3 333.8z" /></svg></a><a class="share-btn fb" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fwhat-is-a-reentrancy-attack-in-smart-contracts" target="_blank" rel="noopener" aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5l0-170.3-52.8 0 0-78.2 52.8 0 0-33.7c0-87.1 39.4-127.5 125-127.5 16.2 0 44.2 3.2 55.7 6.4l0 70.8c-6-.6-16.5-1-29.6-1-42 0-58.2 15.9-58.2 57.2l0 27.8 83.6 0-14.4 78.2-69.3 0 0 175.9C413.8 494.8 512 386.9 512 256z" /></svg></a><a class="share-btn li" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fwhat-is-a-reentrancy-attack-in-smart-contracts" target="_blank" rel="noopener" aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M416 32L31.9 32C14.3 32 0 46.5 0 64.3L0 447.7C0 465.5 14.3 480 31.9 480L416 480c17.6 0 32-14.5 32-32.3l0-383.4C448 46.5 433.6 32 416 32zM135.4 416l-66.4 0 0-213.8 66.5 0 0 213.8-.1 0zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77zM384.3 416l-66.4 0 0-104c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9l0 105.8-66.4 0 0-213.8 63.7 0 0 29.2 .9 0c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9l0 117.2z" /></svg></a><a class="share-btn rd" href="https://www.reddit.com/submit?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fwhat-is-a-reentrancy-attack-in-smart-contracts&amp;title=What%20Is%20a%20Reentrancy%20Attack%20in%20Smart%20Contracts%3F%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on Reddit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M0 256C0 114.6 114.6 0 256 0S512 114.6 512 256 397.4 512 256 512L37.1 512c-13.7 0-20.5-16.5-10.9-26.2L75 437C28.7 390.7 0 326.7 0 256zM349.6 153.6c23.6 0 42.7-19.1 42.7-42.7s-19.1-42.7-42.7-42.7c-20.6 0-37.8 14.6-41.8 34-34.5 3.7-61.4 33-61.4 68.4l0 .2c-37.5 1.6-71.8 12.3-99 29.1-10.1-7.8-22.8-12.5-36.5-12.5-33 0-59.8 26.8-59.8 59.8 0 24 14.1 44.6 34.4 54.1 2 69.4 77.6 125.2 170.6 125.2s168.7-55.9 170.6-125.3c20.2-9.6 34.1-30.2 34.1-54 0-33-26.8-59.8-59.8-59.8-13.7 0-26.3 4.6-36.4 12.4-27.4-17-62.1-27.7-100-29.1l0-.2c0-25.4 18.9-46.5 43.4-49.9 4.4 18.8 21.3 32.8 41.5 32.8l.1 .2zM177.1 246.9c16.7 0 29.5 17.6 28.5 39.3s-13.5 29.6-30.3 29.6-31.4-8.8-30.4-30.5 15.4-38.3 32.1-38.3l.1-.1zm190.1 38.3c1 21.7-13.7 30.5-30.4 30.5s-29.3-7.9-30.3-29.6 11.8-39.3 28.5-39.3 31.2 16.6 32.1 38.3l.1 .1zm-48.1 56.7c-10.3 24.6-34.6 41.9-63 41.9s-52.7-17.3-63-41.9c-1.2-2.9 .8-6.2 3.9-6.5 18.4-1.9 38.3-2.9 59.1-2.9s40.7 1 59.1 2.9c3.1 .3 5.1 3.6 3.9 6.5z" /></svg></a><a class="share-btn email" href="mailto:?subject=What%20Is%20a%20Reentrancy%20Attack%20in%20Smart%20Contracts%3F%20-%20PulseGeek&amp;body=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fwhat-is-a-reentrancy-attack-in-smart-contracts" aria-label="Share via email"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M61.4 64C27.5 64 0 91.5 0 125.4 0 126.3 0 127.1 .1 128L0 128 0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-256-.1 0c0-.9 .1-1.7 .1-2.6 0-33.9-27.5-61.4-61.4-61.4L61.4 64zM464 192.3L464 384c0 8.8-7.2 16-16 16L64 400c-8.8 0-16-7.2-16-16l0-191.7 154.8 117.4c31.4 23.9 74.9 23.9 106.4 0L464 192.3zM48 125.4C48 118 54 112 61.4 112l389.2 0c7.4 0 13.4 6 13.4 13.4 0 4.2-2 8.2-5.3 10.7L280.2 271.5c-14.3 10.8-34.1 10.8-48.4 0L53.3 136.1c-3.3-2.5-5.3-6.5-5.3-10.7z" /></svg></a></div><article><header style="text-align:center; margin-bottom:2rem;"><h1>What Is a Reentrancy Attack in Smart Contracts?</h1><p><small> By <a href="https://pulsegeek.com/authors/rhea-kavinsky/">Rhea Kavinsky</a> &bull; Published <time datetime="2025-10-11T23:02:00-05:00" title="2025-10-11T23:02:00-05:00">October 11, 2025</time></small></p><figure><picture><source type="image/webp" srcset="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero-512.webp" media="(max-width: 512px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero-768.webp" media="(max-width: 768px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero-1024.webp" media="(max-width: 1024px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero-1536.webp" media="(max-width: 1536px)"><img src="https://pulsegeek.com/articles/what-is-a-reentrancy-attack-in-smart-contracts/hero-1536.webp" alt="A stylized smart contract vault with recursive call shadows and looping arrows" width="1536" height="1024" decoding="async" fetchpriority="high" style="border-radius:8px; max-width:100%;" /></picture><figcaption style="text-align:center; font-style:italic; margin-top:0.5rem;"> A looping call pattern highlights how a reentrancy attack can drain a contract. </figcaption></figure></header><p>What is a reentrancy attack in smart contracts? In short, it is an exploit where an external call unexpectedly returns control to the caller before state updates finalize. That timing lets an attacker repeat a withdrawal while balances still show the old value. This article previews the core mechanics behind the attack, demonstrates a minimal vulnerable pattern, then stacks defenses you can apply today. We will compare patterns, show one concise <a class="glossary-term" href="https://pulsegeek.com/glossary/solidity/" data-tooltip="Solidity is a programming language for writing smart contracts, mainly on EVM-compatible blockchains. It looks like JavaScript and adds features for blockchain data, events, and access control." tabindex="0">Solidity</a> example, and outline auditing steps that catch issues early. By the end, you will understand why reentrancy thrives on nonfinalized state and how disciplined interaction order prevents it.</p><section class="pg-summary-block pg-key-takeaways" role="note" aria-label="Key takeaways"><h2>Key takeaways</h2><ul><li><a class="glossary-term" href="https://pulsegeek.com/glossary/reentrancy/" data-tooltip="Reentrancy is a vulnerability where a contract’s external call lets another contract call back before state updates finish, enabling repeated withdrawals or logic misuse." tabindex="0">Reentrancy</a> exploits callouts before state updates finalize in storage.</li><li>Checks then effects then interactions reduces exploitable reentry surfaces.</li><li>Use pull payments and reentrancy guards for higher safety margins.</li><li>Audit external calls, modifiers, and fallback paths under realistic gas.</li><li>Monitor events and deltas to detect anomalous repeated withdrawals quickly.</li></ul></section><h2 id="what-is-reentrancy" data-topic="Mechanics" data-summary="How reentrancy works and why it breaks invariants">What is a reentrancy attack and why does it work?</h2><p>A reentrancy attack occurs when a contract calls an external address that can execute code and call back into the caller before the original function finishes. The key insight is that storage often still contains preupdate values during that window, which leaves invariants temporarily false. For example, a withdraw function that sends funds before decreasing the recorded balance gives an attacker a chance to reenter and withdraw again. The pattern thrives on interleaving: state changes are deferred, yet capabilities remain available. Understanding this interleaving is crucial because robust defenses rely on finalizing storage first or eliminating unnecessary external calls entirely.</p><p>The attack’s power comes from reusing permissions that should have been consumed by the first execution frame. When the external call happens early, the callee’s fallback or receive function can recursively trigger the same entry path while authorizations and allowances still appear valid. Consider a vault that calls token transfer and only after that updates its internal accounting. If the callee reenters, it meets the same branch conditions again, allowing multiple transfers. The vulnerability is not limited to ether sends, since any external call might yield control. The common thread is reliance on state that has not yet been committed.</p><p>Not every external call is dangerous, yet each adds an execution path that deserves scrutiny. Safe cases include read only external static calls that cannot modify state or send funds. Riskier cases include low level calls, token hooks, and untrusted callbacks. A useful rule of thumb is to assume any untrusted target can reenter unless you explicitly prevent it. Developers should identify critical invariants, such as total reserves never going negative, then ensure each external interaction cannot observe a broken intermediate state. This mindset shifts effort from patching symptoms to designing functions that never expose half finished transitions.</p><div class="pg-section-summary" data-for="#what-is-reentrancy" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Reentrancy exploits external callbacks observing preupdate state and invariants.</li><li>Identify risky interactions and design functions that avoid half finished states.</li></ul></div><h2 id="variants-and-prevention" data-topic="Patterns and defenses" data-summary="Examples and safe design patterns to prevent reentrancy">Common variants and practical prevention patterns</h2><p>Several variants appear in practice, but they share the same timing flaw. Classic reentrancy targets direct ether sends that occur before balances update. Cross function reentrancy arises when a callback enters a different function that still relies on outdated storage. Read only reentrancy changes observed price or accounting by manipulating another protocol during a view, which later affects stateful checks. A reliable first line of defense is checks then effects then interactions. Verify preconditions, finalize accounting in storage, and only then call out. This order shrinks the window where state is inconsistent while keeping function intent readable.</p><p>Before code, define clear invariants like balance after withdrawal equals previous minus amount and ensure they hold before any external call. When interacting with tokens, prefer pull payments that let users claim later instead of pushing funds in the same transaction. For surface reduction, avoid unnecessary callbacks and limit low level call patterns. Where appropriate, use a proven reentrancy guard modifier to block reentry within the same transaction context. Defense in depth matters because a single measure can fail under edge cases like unexpected token hooks or gas refunds that change execution flow.</p><p>The following snippet contrasts a vulnerable withdraw with a fixed variant that uses checks then effects then interactions plus a simple guard. The goal is to observe how committing storage before the external transfer prevents repeated drains. Review modifier placement and state ordering, then adapt the pattern to your codebase with the narrowest possible external calls.</p><figure class="code-example" data-language="solidity" data-caption="Solidity example showing a vulnerable withdraw and a guarded, reordered fix" data-filename="ReentrancyExample.sol"><pre tabindex="0"><code class="language-solidity">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract VulnerableVault {
    mapping(address =&gt; uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] &gt;= amount, "insufficient");
        // Interaction before effects enables reentrancy.
        (bool ok, ) = msg.sender.call{value: amount}("");
        require(ok, "send failed");
        balances[msg.sender] -= amount; // Late effect
    }
}

abstract contract ReentrancyGuard {
    uint256 private _entered;
    modifier nonReentrant() {
        require(_entered == 0, "reentered");
        _entered = 1;
        _;
        _entered = 0;
    }
}

contract SafeVault is ReentrancyGuard {
    mapping(address =&gt; uint256) public balances;

    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) external nonReentrant {
        require(balances[msg.sender] &gt;= amount, "insufficient");
        balances[msg.sender] -= amount; // Effects first
        (bool ok, ) = msg.sender.call{value: amount}(""); // Interaction last
        require(ok, "send failed");
    }
}
    </code></pre><figcaption>Solidity example showing a vulnerable withdraw and a guarded, reordered fix</figcaption></figure><div class="pg-section-summary" data-for="#variants-and-prevention" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Commit storage before calling out and consider a reentrancy guard.</li><li>Prefer pull payments and minimize untrusted callbacks or low level calls.</li></ul></div><h2 id="auditing-and-detection" data-topic="Audit steps" data-summary="Manual checks, tools, and monitoring guidance">Auditing steps, testing hints, and runtime monitoring</h2><p>Start with manual trace analysis of every function that performs an external call, including token transfers, delegatecalls, and untrusted callbacks. For each, list preconditions, storage writes, and postconditions. Then confirm that all mutations to balances, allowances, or ownership occur before a call leaves the contract. Unit test with reentry stubs that implement receive and fallback to call target functions repeatedly until a guard triggers. Differential testing helps too by comparing invariant snapshots before and after complex flows. This structured approach reveals interleavings that static tools might miss and clarifies where a simple reorder eliminates risk.</p><p>Static and symbolic tools accelerate coverage, but they complement rather than replace reasoning about invariants. Linters can flag low level calls or unsafe send patterns while analyzers explore paths that allow nested execution. Property based tests enforce invariants across many random sequences and input sizes. Combine these with fuzzers that simulate hostile callbacks and low gas conditions to surface edge cases in payable code. For broader context on secure habits and tooling, see a practical guide to <a href="https://pulsegeek.com/articles/blockchain-security-threat-models-tools-and-culture">blockchain security fundamentals, tooling, and secure engineering habits</a> which pairs mindset with method.</p><p>After deployment, continuous monitoring catches issues that slipped through review. Emit events on withdrawals, claims, and admin actions, then alert on abnormal burst patterns or repeated calls within a short block window. Track deltas between total reserves and aggregated balances, since widening gaps often precede incidents. Pair these signals with on chain explorers and dashboards to reconstruct execution paths during incidents. If you are newer to the domain, this primer on <a href="https://pulsegeek.com/articles/smart-contracts-explained-from-code-to-on-chain-trust">what smart contracts are and how they run safely</a> helps connect design choices to runtime behavior so alerts map to concrete risks.</p><div class="pg-section-summary" data-for="#auditing-and-detection" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Map external calls, finalize effects early, and enforce invariants in tests.</li><li>Use tools and alerts to explore paths and catch anomalous call bursts.</li></ul></div><h2 id="looking-ahead" data-topic="Next steps" data-summary="Forward looking wrap-up with practical next actions">Where to go next and how to stay vigilant</h2><p>Reentrancy defense is most reliable when it becomes a default design habit. Treat any untrusted external call as a potential reentry vector and require effects to commit before leaving your contract. Add a guard only where it clarifies intent and annotate invariants directly in tests to keep them visible during refactors. Teams often benefit from a shared checklist that forces a written record of external calls and expected state transitions. This shared context reduces the chance that a late feature adds a risky path without review and keeps code readable under pressure.</p><p>As systems integrate, cross contract assumptions pose hidden risks. A token changing its callback behavior or a lending protocol altering transfer semantics can invalidate prior guarantees. To adapt, prefer minimal interfaces, specific allowlists, and time boxed approvals. When upstream risk cannot be eliminated, isolate interactions in small modules that can fail closed without draining core balances. Batching independent state transitions also limits the blast radius of any single call reverting or reentering. These patterns cost a little flexibility, but they convert uncertainty into explicit boundaries.</p><p>Finally, turn incidents into learning loops. Capture a postmortem that lists the invariant that failed, the earliest detection point, and the smallest change that would have prevented it. Backport that change into templates or base contracts so new code inherits the fix. Schedule recurring drills that rotate roles between developer, reviewer, and adversary to sharpen intuition. The goal is steady pressure that keeps reentrancy uncommon and short lived when it appears. With disciplined patterns and active monitoring, your contracts can evolve without reopening old hazards.</p><div class="pg-section-summary" data-for="#looking-ahead" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Make safe interaction order a habit and document external call expectations.</li><li>Harden boundaries and convert incident insights into reusable templates.</li></ul></div><section id="article-glossary" class="article-glossary" aria-labelledby="article-glossary-heading"><h2 id="article-glossary-heading">Key terms</h2><ul class="article-glossary-list"><li><a href="https://pulsegeek.com/glossary/reentrancy/">Reentrancy</a><span class="def"> — Reentrancy is a vulnerability where a contract’s external call lets another contract call back before state updates finish, enabling repeated withdrawals or logic misuse.</span></li><li><a href="https://pulsegeek.com/glossary/solidity/">Solidity</a><span class="def"> — Solidity is a programming language for writing smart contracts, mainly on EVM-compatible blockchains. It looks like JavaScript and adds features for blockchain data, events, and access control.</span></li></ul></section><section id="faqs" class="pg-faq" aria-labelledby="faqs-heading"><h2 id="faqs-heading">Frequently asked questions</h2><div class="faq-item"><h3>What is a reentrancy attack?</h3><p>A reentrancy attack is when an external call regains control and reenters a function before it finishes updating state. The attacker exploits this window to repeat actions like withdrawals while balances still show old values.</p></div><div class="faq-item"><h3>Why are reentrancy attacks dangerous?</h3><p>They break invariants by observing and exploiting half finished state. If a contract sends value before decreasing balances or limits, an attacker can reenter and perform the action again, draining funds or bypassing accounting checks.</p></div><div class="faq-item"><h3>How do I prevent reentrancy?</h3><p>Finalize storage before external calls using checks then effects then interactions. Prefer pull payments. Use a reentrancy guard where it adds clarity. Reduce low level calls, avoid untrusted callbacks, and test invariants under hostile stubs.</p></div><div class="faq-item"><h3>How can I test for reentrancy locally?</h3><p>Create a malicious stub that implements receive and fallback which reenter target functions. Run property based and fuzz tests that assert invariants after many sequences. Include low gas scenarios to explore alternate execution paths.</p></div><div class="faq-item"><h3>Does using pull payments help?</h3><p>Yes. Pull payments move the transfer to a separate user initiated call, so state is committed before any external interaction occurs. This reduces reentry surface and keeps accounting clear across independent transactions.</p></div></section><script type="application/ld+json">{ "@context": "https://schema.org", "@type": "FAQPage", "mainEntity": [ { "@type": "Question", "name": "What is a reentrancy attack?", "acceptedAnswer": { "@type": "Answer", "text": "A reentrancy attack is when an external call regains control and reenters a function before it finishes updating state. The attacker exploits this window to repeat actions like withdrawals while balances still show old values." } }, { "@type": "Question", "name": "Why are reentrancy attacks dangerous?", "acceptedAnswer": { "@type": "Answer", "text": "They break invariants by observing and exploiting half finished state. If a contract sends value before decreasing balances or limits, an attacker can reenter and perform the action again, draining funds or bypassing accounting checks." } }, { "@type": "Question", "name": "How do I prevent reentrancy?", "acceptedAnswer": { "@type": "Answer", "text": "Finalize storage before external calls using checks then effects then interactions. Prefer pull payments. Use a reentrancy guard where it adds clarity. Reduce low level calls, avoid untrusted callbacks, and test invariants under hostile stubs." } }, { "@type": "Question", "name": "How can I test for reentrancy locally?", "acceptedAnswer": { "@type": "Answer", "text": "Create a malicious stub that implements receive and fallback which reenter target functions. Run property based and fuzz tests that assert invariants after many sequences. Include low gas scenarios to explore alternate execution paths." } }, { "@type": "Question", "name": "Does using pull payments help?", "acceptedAnswer": { "@type": "Answer", "text": "Yes. Pull payments move the transfer to a separate user initiated call, so state is committed before any external interaction occurs. This reduces reentry surface and keeps accounting clear across independent transactions." } } ]
}</script></article><aside class="related-articles" aria-label="Related articles"><h2>Related Articles</h2><ul><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/what-is-a-blockexplorer-reading-on-chain-data-clearly">What Is a Blockexplorer? Reading On&#x2011;Chain Data Clearly</a></h3><p>Learn what a blockexplorer does, how to read on-chain data, and how explorers support security work like tracing funds, checking contract risks, and verifying transactions.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/blockchain-transaction-tracker-tools-which-one-fits">Blockchain Transaction Tracker Tools: Which One Fits?</a></h3><p>Compare blockchain transaction tracker tools by coverage, decoding quality, labeling, alerts, and privacy. See strengths, tradeoffs, and a small code demo to monitor activity responsibly.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/smart-contract-auditing-basics-a-safe-start-checklist">Smart Contract Auditing Basics: A Safe Start Checklist</a></h3><p>Learn smart contract auditing basics with a practical, stepwise checklist. Scope risks, set up tooling, spot common flaws, test assumptions, and ship safer code.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/smart-contract-vulnerabilities-the-common-pitfalls">Smart Contract Vulnerabilities: The Common Pitfalls</a></h3><p>Explore frequent smart contract vulnerabilities with clear examples, tradeoffs, and fixes. Learn auditing habits, guard patterns, and tools to reduce risk before mainnet deployment.</p></article></li></ul></aside></main><footer class="container" itemscope itemtype="https://schema.org/Organization"><hr /><nav aria-label="Footer navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"><ul style="list-style:none; padding-left:0; margin:0; display:flex; flex-wrap:wrap; gap:.65rem;"><li itemprop="name"><a href="https://pulsegeek.com/about/" itemprop="url">About</a></li><li itemprop="name"><a href="https://pulsegeek.com/contact/" itemprop="url">Contact</a></li><li itemprop="name"><a href="https://pulsegeek.com/privacy/" itemprop="url">Privacy&nbsp;Policy</a></li><li itemprop="name"><a href="https://pulsegeek.com/terms/" itemprop="url">Terms&nbsp;of&nbsp;Service</a></li><li itemprop="name"><a href="https://pulsegeek.com/site-map/" itemprop="url">HTML&nbsp;Sitemap</a></li><li itemprop="name"><a href="https://pulsegeek.com/rss.xml" itemprop="url" title="RSS 2.0 feed">RSS&nbsp;Feed</a></li><li itemprop="name"><a href="https://pulsegeek.com/atom.xml" itemprop="url" title="Atom 1.0 feed">Atom</a></li><li itemprop="name"><a href="https://pulsegeek.com/feed.json" itemprop="url" title="JSON Feed 1.1">JSON&nbsp;Feed</a></li></ul></nav><small style="display:block; margin-top:.75rem;"> © 2025 <span itemprop="name">PulseGeek</span>. All rights reserved. </small></footer><script type="module">
for (const code of document.querySelectorAll('figure.code-example pre code')) {
  if (code.dataset.lnDone) continue;
  const raw = code.innerHTML.replace(/\r/g,'');
  let lines = raw.split('\n');
  if (lines.length && lines[lines.length-1] === '') lines.pop();
  if (lines.length < 2) continue;
  code.innerHTML = lines.map(l => `<span>${l || '&#8203;'}</span>`).join('\n');
  code.dataset.lnDone = '1';
  code.closest('figure.code-example')?.classList.add('line-numbers');
}
</script></body></html> 