<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><title>On-Chain Randomness Security: Oracles, VRFs, and Risks - PulseGeek</title><meta name="description" content="Compare oracle feeds, VRFs, and in-protocol randomness for secure lotteries and leader election. See attack surfaces, bias risks, and practical mitigations that protect on-chain fairness." /><meta name="author" content="Maya Navarre" /><link rel="canonical" href="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks" /><link rel="apple-touch-icon" sizes="180x180" href="https://pulsegeek.com/apple-touch-icon.png" /><link rel="icon" type="image/png" sizes="32x32" href="https://pulsegeek.com/favicon-32x32.png" /><link rel="icon" type="image/png" sizes="16x16" href="https://pulsegeek.com/favicon-16x16.png" /><link rel="manifest" href="https://pulsegeek.com/site.webmanifest" /><link rel="alternate" type="application/rss+xml" title="PulseGeek RSS feed" href="https://pulsegeek.com/rss.xml" /><link rel="alternate" type="application/atom+xml" title="PulseGeek Atom feed" href="https://pulsegeek.com/atom.xml" /><link rel="alternate" type="application/feed+json" title="PulseGeek JSON feed" href="https://pulsegeek.com/feed.json" /><meta property="og:title" content="On-Chain Randomness Security: Oracles, VRFs, and Risks" /><meta property="og:type" content="article" /><meta property="og:url" content="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks" /><meta property="og:image" content="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero.webp" /><meta property="og:description" content="Compare oracle feeds, VRFs, and in-protocol randomness for secure lotteries and leader election. See attack surfaces, bias risks, and practical mitigations that protect on-chain fairness." /><meta property="og:site_name" content="PulseGeek" /><meta property="og:locale" content="en_US" /><meta property="article:author" content="Maya Navarre" /><meta property="article:publisher" content="PulseGeek" /><meta property="article:published_time" content="2025-10-17T09:13:00.0000000" /><meta property="article:modified_time" content="2025-09-10T18:05:08.5991556" /><meta property="article:section" content="Technology / Blockchain / Blockchain Cryptography" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:title" content="On-Chain Randomness Security: Oracles, VRFs, and Risks" /><meta name="twitter:description" content="Compare oracle feeds, VRFs, and in-protocol randomness for secure lotteries and leader election. See attack surfaces, bias risks, and practical mitigations that protect on-chain fairness." /><meta name="twitter:image" content="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero.webp" /><meta name="twitter:label1" content="Author" /><meta name="twitter:data1" content="Maya Navarre" /><script type="application/ld+json"> {"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks#article","headline":"On-Chain Randomness Security: Oracles, VRFs, and Risks","description":"Compare oracle feeds, VRFs, and in-protocol randomness for secure lotteries and leader election. See attack surfaces, bias risks, and practical mitigations that protect on-chain fairness.","image":"https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero.webp","author":{"@type":"Person","@id":"https://pulsegeek.com/authors/maya-navarre#author","name":"Maya Navarre","url":"https://pulsegeek.com/authors/maya-navarre"},"publisher":{"@id":"https://pulsegeek.com#organization"},"datePublished":"2025-10-17T09:13:00-05:00","dateModified":"2025-09-10T18:05:08.5991556-05:00","mainEntityOfPage":"https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks","wordCount":"1944","inLanguage":"en-US"},{"@type":"Person","@id":"https://pulsegeek.com/authors/maya-navarre#author","name":"Maya Navarre","url":"https://pulsegeek.com/authors/maya-navarre"},{"@type":"Organization","@id":"https://pulsegeek.com#organization","url":"https://pulsegeek.com","name":"PulseGeek","logo":{"@type":"ImageObject","url":"https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero.webp"}},{"@type":"WebSite","@id":"https://pulsegeek.com#website","url":"https://pulsegeek.com","name":"PulseGeek"},{"@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://pulsegeek.com"},{"@type":"ListItem","position":2,"name":"Technology / Blockchain / Blockchain Cryptography","item":"https://pulsegeek.com/technology / blockchain / blockchain cryptography"},{"@type":"ListItem","position":3,"name":"On-Chain Randomness Security: Oracles, VRFs, and Risks","item":"https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks"}]}]} </script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KN2EBXS37E"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KN2EBXS37E'); </script><link href="https://pulsegeek.com/css/pico.green.min.css" rel="stylesheet" /><link href="https://pulsegeek.com/css/site.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container container-narrow"><nav><ul><li><a href="https://pulsegeek.com/" class="brand" aria-label="PulseGeek home"><img src="https://pulsegeek.com/images/logo.png" srcset="https://pulsegeek.com/images/logo.png 1x, https://pulsegeek.com/images/logo@2x.png 2x" alt="PulseGeek" width="308" height="64" class="brand-logo" decoding="async" fetchpriority="high"></a></li></ul><ul><li><a href="https://pulsegeek.com/technology/">Technology</a></li></ul></nav></div></header><main class="container"><nav aria-label="Breadcrumb" class="breadcrumb"><ol><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><a href="https://pulsegeek.com/technology/" title="Technology">Technology</a></li><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><span>Blockchain</span></li></ol></nav><div class="share-buttons" aria-label="Share this article"><span>Share:</span><a class="share-btn x" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fon-chain-randomness-security-oracles-vrfs-and-risks&amp;text=On-Chain%20Randomness%20Security%3A%20Oracles%2C%20VRFs%2C%20and%20Risks%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on X / Twitter"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M357.2 48L427.8 48 273.6 224.2 455 464 313 464 201.7 318.6 74.5 464 3.8 464 168.7 275.5-5.2 48 140.4 48 240.9 180.9 357.2 48zM332.4 421.8l39.1 0-252.4-333.8-42 0 255.3 333.8z" /></svg></a><a class="share-btn fb" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fon-chain-randomness-security-oracles-vrfs-and-risks" target="_blank" rel="noopener" aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5l0-170.3-52.8 0 0-78.2 52.8 0 0-33.7c0-87.1 39.4-127.5 125-127.5 16.2 0 44.2 3.2 55.7 6.4l0 70.8c-6-.6-16.5-1-29.6-1-42 0-58.2 15.9-58.2 57.2l0 27.8 83.6 0-14.4 78.2-69.3 0 0 175.9C413.8 494.8 512 386.9 512 256z" /></svg></a><a class="share-btn li" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fon-chain-randomness-security-oracles-vrfs-and-risks" target="_blank" rel="noopener" aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M416 32L31.9 32C14.3 32 0 46.5 0 64.3L0 447.7C0 465.5 14.3 480 31.9 480L416 480c17.6 0 32-14.5 32-32.3l0-383.4C448 46.5 433.6 32 416 32zM135.4 416l-66.4 0 0-213.8 66.5 0 0 213.8-.1 0zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77zM384.3 416l-66.4 0 0-104c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9l0 105.8-66.4 0 0-213.8 63.7 0 0 29.2 .9 0c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9l0 117.2z" /></svg></a><a class="share-btn rd" href="https://www.reddit.com/submit?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fon-chain-randomness-security-oracles-vrfs-and-risks&amp;title=On-Chain%20Randomness%20Security%3A%20Oracles%2C%20VRFs%2C%20and%20Risks%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on Reddit"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M0 256C0 114.6 114.6 0 256 0S512 114.6 512 256 397.4 512 256 512L37.1 512c-13.7 0-20.5-16.5-10.9-26.2L75 437C28.7 390.7 0 326.7 0 256zM349.6 153.6c23.6 0 42.7-19.1 42.7-42.7s-19.1-42.7-42.7-42.7c-20.6 0-37.8 14.6-41.8 34-34.5 3.7-61.4 33-61.4 68.4l0 .2c-37.5 1.6-71.8 12.3-99 29.1-10.1-7.8-22.8-12.5-36.5-12.5-33 0-59.8 26.8-59.8 59.8 0 24 14.1 44.6 34.4 54.1 2 69.4 77.6 125.2 170.6 125.2s168.7-55.9 170.6-125.3c20.2-9.6 34.1-30.2 34.1-54 0-33-26.8-59.8-59.8-59.8-13.7 0-26.3 4.6-36.4 12.4-27.4-17-62.1-27.7-100-29.1l0-.2c0-25.4 18.9-46.5 43.4-49.9 4.4 18.8 21.3 32.8 41.5 32.8l.1 .2zM177.1 246.9c16.7 0 29.5 17.6 28.5 39.3s-13.5 29.6-30.3 29.6-31.4-8.8-30.4-30.5 15.4-38.3 32.1-38.3l.1-.1zm190.1 38.3c1 21.7-13.7 30.5-30.4 30.5s-29.3-7.9-30.3-29.6 11.8-39.3 28.5-39.3 31.2 16.6 32.1 38.3l.1 .1zm-48.1 56.7c-10.3 24.6-34.6 41.9-63 41.9s-52.7-17.3-63-41.9c-1.2-2.9 .8-6.2 3.9-6.5 18.4-1.9 38.3-2.9 59.1-2.9s40.7 1 59.1 2.9c3.1 .3 5.1 3.6 3.9 6.5z" /></svg></a><a class="share-btn email" href="mailto:?subject=On-Chain%20Randomness%20Security%3A%20Oracles%2C%20VRFs%2C%20and%20Risks%20-%20PulseGeek&amp;body=https%3A%2F%2Fpulsegeek.com%2Farticles%2Fon-chain-randomness-security-oracles-vrfs-and-risks" aria-label="Share via email"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M61.4 64C27.5 64 0 91.5 0 125.4 0 126.3 0 127.1 .1 128L0 128 0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-256-.1 0c0-.9 .1-1.7 .1-2.6 0-33.9-27.5-61.4-61.4-61.4L61.4 64zM464 192.3L464 384c0 8.8-7.2 16-16 16L64 400c-8.8 0-16-7.2-16-16l0-191.7 154.8 117.4c31.4 23.9 74.9 23.9 106.4 0L464 192.3zM48 125.4C48 118 54 112 61.4 112l389.2 0c7.4 0 13.4 6 13.4 13.4 0 4.2-2 8.2-5.3 10.7L280.2 271.5c-14.3 10.8-34.1 10.8-48.4 0L53.3 136.1c-3.3-2.5-5.3-6.5-5.3-10.7z" /></svg></a></div><article><header style="text-align:center; margin-bottom:2rem;"><h1>On-Chain Randomness Security: Oracles, VRFs, and Risks</h1><p><small> By <a href="https://pulsegeek.com/authors/maya-navarre/">Maya Navarre</a> &bull; Published <time datetime="2025-10-17T04:13:00-05:00" title="2025-10-17T04:13:00-05:00">October 17, 2025</time></small></p><figure><picture><source type="image/webp" srcset="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero-512.webp" media="(max-width: 512px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero-768.webp" media="(max-width: 768px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero-1024.webp" media="(max-width: 1024px)"><source type="image/webp" srcset="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero-1536.webp" media="(max-width: 1536px)"><img src="https://pulsegeek.com/articles/on-chain-randomness-security-oracles-vrfs-and-risks/hero-1536.webp" alt="Abstract beacon tower casting light over a blockchain grid at night" width="1536" height="1024" decoding="async" fetchpriority="high" style="border-radius:8px; max-width:100%;" /></picture><figcaption style="text-align:center; font-style:italic; margin-top:0.5rem;"> A stylized beacon over a ledger grid hints at randomness security. </figcaption></figure></header><p>Random draws decide who leads, who validates, and who wins prizes, which makes <a class="glossary-term" href="https://pulsegeek.com/glossary/entropy/" data-tooltip="Entropy measures uncertainty in data. Systems need strong entropy to generate keys, seeds, and random numbers that attackers cannot predict or reproduce." tabindex="0">randomness</a> security a core protocol concern. On-chain systems often compare oracles, VRFs, and in-protocol beacons because each design resists bias differently under pressure. The comparison matters whenever value meets coordination, like leader election or loot boxes, where small weaknesses invite grinding or reorg games. This article maps the mechanics and risks, then shows patterns that convert brittle lotteries into robust flows developers can verify.</p><section class="pg-summary-block pg-key-takeaways" role="note" aria-label="Key takeaways"><h2>Key takeaways</h2><ul><li>VRFs provide public proofs that reduce bias and simplify audits.</li><li>Oracles add liveness but expand trust and censorship surfaces.</li><li>Beacons tie randomness to consensus, lowering external dependencies.</li><li>Commit reveal thwarts grinding by separating choice from disclosure.</li><li>Delayed finality cushions reorg risk for fairness-critical draws.</li></ul></section><h2 id="security-properties" data-topic="Security properties" data-summary="Define what makes on-chain randomness safe.">Security properties that define safe on-chain randomness</h2><p>Strong on-chain randomness starts with bias resistance, which means adversaries cannot meaningfully change the distribution or steer outcomes. A useful mental model asks whether an attacker can choose when to participate, whether they can see partial outcomes before committing, and whether they can censor or reorder messages. For example, a validator who sees a near-winning outcome might withhold a block and try again, which is grinding. Designs aim to constrain those decisions using proofs, delayed finality, and sealed commitments, because narrowing freedom to act at the right moments reduces exploitable variance.</p><p>Unpredictability is the second pillar and differs from secrecy because an output can be verifiable yet unknowable until a fixed point in time. <a class="glossary-term" href="https://pulsegeek.com/glossary/verifiable-random-function/" data-tooltip="A verifiable random function produces randomness tied to a public key, along with a proof that anyone can verify. It supports fair leader election and lotteries without trusted parties." tabindex="0">VRF</a> outputs are predictable only to the secret key holder before reveal, while beacons become unpredictable until consensus seals a block. Protocols also weigh forward security, which asks whether leaking a key later reveals past outputs. As a rule of thumb, tie randomness to events that cannot be replayed or forged, then bind revelation to proofs that are efficient to verify on chain.</p><p>Liveness and availability complete the picture because even unbiased randomness is harmful if it stalls economic processes. Oracles can bridge fresh entropy quickly, yet they introduce routing and censorship surfaces. Beacons are often timely during normal operation, but outages couple application liveness to network health. Designers should set maximum wait windows and fallback paths, such as switching from a single source to a combined source after N blocks. This balance ensures games, leader selection, and grants proceed even when specific suppliers degrade.</p><div class="pg-section-summary" data-for="#security-properties" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Bias resistance, unpredictability, and liveness define secure randomness.</li><li>Constrain attacker choices with proofs, commitments, and timed reveals.</li></ul></div><h2 id="approach-comparison" data-topic="Approach comparison" data-summary="Contrast oracles, VRFs, and beacons.">Oracles, VRFs, and beacons compared by guarantees and risks</h2><p><a class="glossary-term" href="https://pulsegeek.com/glossary/oracle/" data-tooltip="An oracle supplies off-chain data to on-chain contracts, such as prices or weather. Secure oracle design prevents manipulation and minimizes trust in single data sources." tabindex="0">Oracle</a> relays fetch randomness from external systems and deliver results on chain with signatures or proofs. The appeal is operational simplicity and flexible sources, but the cost is expanded trust and potential censorship if relayers delay unwelcome draws. Security rises when oracles include non-interactive proofs or aggregate signatures across independent operators. Still, developers must model who can refuse delivery, what retry strategy exists, and how fee markets affect timeliness. Use oracles when you need cross-chain reach or specialized beacons, and offset trust with on-chain verification and multi-operator quorums.</p><p>Verifiable random functions generate a random-looking output and a proof that the output matches a unique input and signer key. VRFs shine because anyone can verify the proof on chain, shrinking manipulation to key security and input control. The main risks are key compromise and input grinding, where callers repeat requests to chase favorable draws. Good practice binds inputs to unique, unforgeable salts like block numbers plus requester nonce, and rate limits requestors. Choose VRFs when you want compact proofs, clear audits, and minimal assumptions beyond key custody and proof verification.</p><p>In-protocol beacons derive randomness from consensus artifacts such as block hashes, validator committees, or threshold signatures over epochs. They remove external dependencies and align attacker costs with consensus attacks. The tradeoff is sensitivity to reorgs and the possibility that a large validator set can bias outcomes with withholds. Systems mitigate this by using delayed finality, mixing multiple past epochs, or threshold beacons where a committee signs a value that no member controls alone. Prefer beacons when tight coupling to consensus and ecosystem neutrality matter most.</p><div class="pg-section-summary" data-for="#approach-comparison" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Oracles trade flexibility for added trust and delivery surfaces.</li><li>VRFs and beacons reduce manipulation with proofs and consensus anchoring.</li></ul></div><table><thead><tr><th>Approach</th><th>Main strength</th><th>Primary risk</th></tr></thead><tbody><tr><td>Oracle relay</td><td>Flexible sources and cross-chain reach</td><td>Censorship, delivery delays, trust in operators</td></tr><tr><td>VRF</td><td>Publicly verifiable proofs on chain</td><td>Key compromise, input grinding risk</td></tr><tr><td>Protocol beacon</td><td>Aligned with consensus security</td><td>Reorg sensitivity, validator withholding</td></tr></tbody></table><table><thead><tr><th>Use when</th><th>Mitigation to add</th><th>Latency profile</th></tr></thead><tbody><tr><td>Needing external entropy or multi-chain</td><td>Multi-operator quorum and delivery SLAs</td><td>One or more transactions</td></tr><tr><td>Seeking compact on-chain verification</td><td>Bound inputs and requester throttles</td><td>One transaction</td></tr><tr><td>Prioritizing neutrality and fewer dependencies</td><td>Delay finality and epoch mixing</td><td>One to several blocks</td></tr></tbody></table><h2 id="patterns-mitigations" data-topic="Risk mitigations" data-summary="Apply patterns to curb bias and grinding.">Patterns that curb bias, grinding, and delivery risk</h2><p>Commit reveal separates choice from disclosure so adversaries cannot probe outcomes before locking their input. In practice, participants first publish a commitment that is a hash of a secret salt and their choice, then reveal the salt later to prove consistency. This blocks cherry-picking because the hash binds the earlier promise with one-way difficulty. A simple variant mixes all revealed salts with a beacon or VRF output to produce the final draw. The drawback is a two-step workflow and potential reveal griefing, which you mitigate by slashing or forfeiting deposits for missed reveals.</p><p>Delay and mix techniques reduce sensitivity to single-block fluctuations and shallow reorgs. A practical rule is to reference a randomness seed from K blocks in the past and to finalize a draw only after L confirmations. For example, choose K between 10 and 100 depending on chain reorg depth patterns, then mix the seed with unique per-draw metadata to prevent replay. The cost is latency and gas from additional reads, yet it pays off by neutralizing block withholding that would otherwise favor better outcomes. Applications like lotteries or NFT traits benefit from this cushion.</p><p>The contract below shows a compact commit reveal pattern that combines user entropy with a block hash after a delay. It aims to prevent grinding by enforcing deadlines and punishing late reveals with forfeiture. The expected outcome is a verifiable result that any observer can recompute from on-chain data, assuming participants reveal in time and the delay crosses typical reorg windows.</p><figure class="code-example" data-language="solidity" data-caption="A minimal commit reveal contract that mixes user salts with a delayed block hash."><pre tabindex="0"><code class="language-solidity">
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract CommitRevealRng {
    struct Round {
        uint256 commitDeadline;
        uint256 revealDeadline;
        bytes32 mixedSeed;
        bool finalized;
    }

    mapping(uint256 =&gt; mapping(address =&gt; bytes32)) public commits;
    mapping(uint256 =&gt; Round) public rounds;

    event Committed(uint256 indexed roundId, address indexed user);
    event Revealed(uint256 indexed roundId, address indexed user, bytes32 salt);
    event Finalized(uint256 indexed roundId, bytes32 seed);

    function startRound(uint256 roundId, uint256 commitPeriod, uint256 revealPeriod) external {
        require(rounds[roundId].commitDeadline == 0, "exists");
        rounds[roundId].commitDeadline = block.number + commitPeriod;
        rounds[roundId].revealDeadline = rounds[roundId].commitDeadline + revealPeriod;
        emit Finalized(roundId, bytes32(0));
    }

    function commit(uint256 roundId, bytes32 commitment) external {
        require(block.number &lt; rounds[roundId].commitDeadline, "commit closed");
        require(commits[roundId][msg.sender] == bytes32(0), "already");
        commits[roundId][msg.sender] = commitment;
        emit Committed(roundId, msg.sender);
    }

    function reveal(uint256 roundId, bytes32 salt) external {
        Round storage r = rounds[roundId];
        require(block.number &gt;= r.commitDeadline &amp;&amp; block.number &lt;= r.revealDeadline, "reveal window");
        require(commits[roundId][msg.sender] == keccak256(abi.encodePacked(salt, msg.sender)), "bad salt");
        r.mixedSeed = keccak256(abi.encodePacked(r.mixedSeed, salt));
        delete commits[roundId][msg.sender];
        emit Revealed(roundId, msg.sender, salt);
    }

    function finalize(uint256 roundId, uint256 delay) external {
        Round storage r = rounds[roundId];
        require(!r.finalized, "done");
        require(block.number &gt; r.revealDeadline, "too early");
        // Delay protects against reorgs and withholding
        bytes32 bh = blockhash(block.number - delay);
        bytes32 seed = keccak256(abi.encodePacked(r.mixedSeed, bh, roundId));
        r.finalized = true;
        emit Finalized(roundId, seed);
    }
}
    </code></pre><figcaption>A minimal commit reveal contract that mixes user salts with a delayed block hash.</figcaption></figure><script type="application/ld+json">{ "@context": "https://schema.org", "@type": "SoftwareSourceCode", "programmingLanguage": "<a class="glossary-term" href="https://pulsegeek.com/glossary/solidity/" data-tooltip="Solidity is a programming language for writing smart contracts, mainly on EVM-compatible blockchains. It looks like JavaScript and adds features for blockchain data, events, and access control." tabindex="0">Solidity</a>", "codeSampleType": "snippet", "about": "Commit reveal pattern that mixes participant salts with a delayed block hash to mitigate grinding and reorg bias.", "text": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract CommitRevealRng {\n struct Round {\n uint256 commitDeadline;\n uint256 revealDeadline;\n bytes32 mixedSeed;\n bool finalized;\n }\n\n mapping(uint256 =&gt; mapping(address =&gt; bytes32)) public commits;\n mapping(uint256 =&gt; Round) public rounds;\n\n event Committed(uint256 indexed roundId, address indexed user);\n event Revealed(uint256 indexed roundId, address indexed user, bytes32 salt);\n event Finalized(uint256 indexed roundId, bytes32 seed);\n\n function startRound(uint256 roundId, uint256 commitPeriod, uint256 revealPeriod) external {\n require(rounds[roundId].commitDeadline == 0, \"exists\");\n rounds[roundId].commitDeadline = block.number + commitPeriod;\n rounds[roundId].revealDeadline = rounds[roundId].commitDeadline + revealPeriod;\n emit Finalized(roundId, bytes32(0));\n }\n\n function commit(uint256 roundId, bytes32 commitment) external {\n require(block.number &lt; rounds[roundId].commitDeadline, \"commit closed\");\n require(commits[roundId][msg.sender] == bytes32(0), \"already\");\n commits[roundId][msg.sender] = commitment;\n emit Committed(roundId, msg.sender);\n }\n\n function reveal(uint256 roundId, bytes32 salt) external {\n Round storage r = rounds[roundId];\n require(block.number &gt;= r.commitDeadline &amp;&amp; block.number &lt;= r.revealDeadline, \"reveal window\");\n require(commits[roundId][msg.sender] == keccak256(abi.encodePacked(salt, msg.sender)), \"bad salt\");\n r.mixedSeed = keccak256(abi.encodePacked(r.mixedSeed, salt));\n delete commits[roundId][msg.sender];\n emit Revealed(roundId, msg.sender, salt);\n }\n\n function finalize(uint256 roundId, uint256 delay) external {\n Round storage r = rounds[roundId];\n require(!r.finalized, \"done\");\n require(block.number &gt; r.revealDeadline, \"too early\");\n // Delay protects against reorgs and withholding\n bytes32 bh = blockhash(block.number - delay);\n bytes32 seed = keccak256(abi.encodePacked(r.mixedSeed, bh, roundId));\n r.finalized = true;\n emit Finalized(roundId, seed);\n }\n}\n" }</script><div class="pg-section-summary" data-for="#patterns-mitigations" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Commit reveal and delay mixing limit grinding and reorg bias.</li><li>Use deadlines, penalties, and confirmations to harden fairness.</li></ul></div><h2 id="putting-it-together" data-topic="Design guidance" data-summary="Choose and combine methods wisely.">Choosing the right method and combining sources safely</h2><p>A good selection flow starts with who must be trusted and how much latency you can accept. If minimizing trust is top priority, a VRF or a native beacon anchored to consensus usually offers clear guarantees with on-chain verification. When you need external entropy or cross-chain reach, an oracle can bridge that gap but requires operator diversity and replay protections. Blending approaches is often effective, such as mixing a VRF output with a delayed block hash so both must be biased at once. This composition raises attacker cost while keeping proofs compact.</p><p>Production systems add guardrails that capture edge cases without freezing the application. Define a maximum waiting period for any single source, then fall back to a mixed mode that combines whatever is available. For example, if the VRF response stalls for N blocks, finalize with a mix of past beacon outputs and committed user salts. Publish every step on chain so auditors can replay the logic deterministically. This fail-open design preserves liveness and keeps participants informed, which matters as much as the cryptography when value and reputation are at stake.</p><p>For deeper background on entropy collection and verification patterns, see a broader guide on how to generate secure randomness on-chain using VRFs, beacons, and entropy sources, with best-practice patterns, and a tour of blockchain cryptography that explains hashes, signatures, and randomness in context. These resources help connect mechanism choices with protocol safety and developer ergonomics. They also provide terminology you can reuse when documenting audits and threat models.</p><div class="pg-section-summary" data-for="#putting-it-together" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Match trust tolerance and latency to the right randomness source.</li><li>Plan fallbacks and publish steps so auditors can replay outcomes.</li></ul></div><section id="article-glossary" class="article-glossary" aria-labelledby="article-glossary-heading"><h2 id="article-glossary-heading">Key terms</h2><ul class="article-glossary-list"><li><a href="https://pulsegeek.com/glossary/entropy/">Entropy</a><span class="def"> — Entropy measures uncertainty in data. Systems need strong entropy to generate keys, seeds, and random numbers that attackers cannot predict or reproduce.</span></li><li><a href="https://pulsegeek.com/glossary/oracle/">Oracle</a><span class="def"> — An oracle supplies off-chain data to on-chain contracts, such as prices or weather. Secure oracle design prevents manipulation and minimizes trust in single data sources.</span></li><li><a href="https://pulsegeek.com/glossary/solidity/">Solidity</a><span class="def"> — Solidity is a programming language for writing smart contracts, mainly on EVM-compatible blockchains. It looks like JavaScript and adds features for blockchain data, events, and access control.</span></li><li><a href="https://pulsegeek.com/glossary/verifiable-random-function/">Verifiable Random Function</a><span class="def"> — A verifiable random function produces randomness tied to a public key, along with a proof that anyone can verify. It supports fair leader election and lotteries without trusted parties.</span></li></ul></section><section id="faqs" class="pg-faq" aria-labelledby="faqs-heading"><h2 id="faqs-heading">Frequently asked questions</h2><div class="faq-item"><h3>How does a VRF prevent manipulation by the requester?</h3><p>A VRF returns an output tied to a unique input and key, plus a proof anyone can verify. The requester cannot change the output without failing verification. To stop input grinding, bind the input to a unique nonce and chain data, and rate limit repeated requests.</p></div><div class="faq-item"><h3>Are block hashes safe to use as randomness?</h3><p>Raw block hashes can be biased by miners or validators when the reward is large enough. They become safer when used with delay windows, mixed across multiple past blocks, or combined with external entropy or commitments that limit withholding advantages.</p></div><div class="faq-item"><h3>What is the main risk with oracle-delivered randomness?</h3><p>Delivery risk dominates because operators can censor or delay specific outcomes. Reduce this by using independent operators with quorum rules, on-chain verification of proofs, and clear timeouts that trigger fallback mixing or alternate sources when liveness degrades.</p></div><div class="faq-item"><h3>Why add delayed finality to randomness-dependent actions?</h3><p>Delays cushion shallow reorgs and withholding that could flip outcomes. Waiting a set number of confirmations before finalizing reduces the chance that an attacker benefits from temporary chain reorganizations or timing games around a single block.</p></div></section><script type="application/ld+json">{ "@context": "https://schema.org", "@type": "FAQPage", "mainEntity": [ { "@type": "Question", "name": "How does a VRF prevent manipulation by the requester?", "acceptedAnswer": { "@type": "Answer", "text": "A VRF returns an output tied to a unique input and key, plus a proof anyone can verify. The requester cannot change the output without failing verification. To stop input grinding, bind the input to a unique nonce and chain data, and rate limit repeated requests." } }, { "@type": "Question", "name": "Are block hashes safe to use as randomness?", "acceptedAnswer": { "@type": "Answer", "text": "Raw block hashes can be biased by miners or validators when the reward is large enough. They become safer when used with delay windows, mixed across multiple past blocks, or combined with external entropy or commitments that limit withholding advantages." } }, { "@type": "Question", "name": "What is the main risk with oracle-delivered randomness?", "acceptedAnswer": { "@type": "Answer", "text": "Delivery risk dominates because operators can censor or delay specific outcomes. Reduce this by using independent operators with quorum rules, on-chain verification of proofs, and clear timeouts that trigger fallback mixing or alternate sources when liveness degrades." } }, { "@type": "Question", "name": "Why add delayed finality to randomness-dependent actions?", "acceptedAnswer": { "@type": "Answer", "text": "Delays cushion shallow reorgs and withholding that could flip outcomes. Waiting a set number of confirmations before finalizing reduces the chance that an attacker benefits from temporary chain reorganizations or timing games around a single block." } } ]
}</script><section class="pg-sources" aria-label="Sources and references"><h2>Sources</h2><ul><li><a href="https://www.cloudflare.com/learning/ssl/what-is-a-vrf/" rel="nofollow">What is a VRF</a></li><li><a href="https://beacon.nist.gov/home" rel="nofollow">NIST Randomness Beacon</a></li></ul></section><p>Security choices evolve as networks adopt threshold beacons and broader verifiability. Expect more protocols to mix sources, add proofs to oracle feeds, and standardize replayable audit trails. Teams that treat randomness like a first-class dependency will ship fairer mechanics and resist adversaries as economic stakes grow.</p><p><a href="https://pulsegeek.com/articles/random-number-generation-on-blockchains-secure-methods">How to generate secure randomness on-chain using VRFs, beacons, and entropy sources, with best-practice patterns</a> extends the techniques covered here with design patterns and anti-bias tips. For a broader foundation, see <a href="https://pulsegeek.com/articles/blockchain-cryptography-core-hashes-keys-and-proofs">a clear tour of blockchain cryptography that explains how primitives secure transactions end to end</a>. These references pair well with the comparison above.</p></article><aside class="related-articles" aria-label="Related articles"><h2>Related Articles</h2><ul><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/top-blockchain-network-types-and-how-they-coordinate">Top Blockchain Network Types and How They Coordinate</a></h3><p>Explore public, permissioned, and committee-based blockchain network types. Learn how consensus, randomness beacons, and VRFs coordinate fairness for lotteries and leader election.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/vrf-in-blockchains-verifiable-randomness-explained">VRF in Blockchains: Verifiable Randomness Explained</a></h3><p>Learn how verifiable random functions bring unbiased, tamper-evident randomness to blockchains, powering fair lotteries, secure leader election, and protocol design without trusted coordinators.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/entropy-sources-in-blockchain-gathering-true-random">Entropy Sources in Blockchain: Gathering True Random</a></h3><p>Learn how to gather, mix, and verify entropy sources in blockchain systems using VRFs, beacons, and commit reveal to secure lotteries, leader selection, and fair protocol outcomes.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/randomness-beacons-explained-fairness-you-can-verify">Randomness Beacons Explained: Fairness You Can Verify</a></h3><p>Learn how randomness beacons, entropy, and verifiable random functions deliver unbiased choices on blockchains for lotteries, leader election, and fair protocols.</p></article></li></ul></aside></main><footer class="container" itemscope itemtype="https://schema.org/Organization"><hr /><nav aria-label="Footer navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"><ul style="list-style:none; padding-left:0; margin:0; display:flex; flex-wrap:wrap; gap:.65rem;"><li itemprop="name"><a href="https://pulsegeek.com/about/" itemprop="url">About</a></li><li itemprop="name"><a href="https://pulsegeek.com/contact/" itemprop="url">Contact</a></li><li itemprop="name"><a href="https://pulsegeek.com/privacy/" itemprop="url">Privacy&nbsp;Policy</a></li><li itemprop="name"><a href="https://pulsegeek.com/terms/" itemprop="url">Terms&nbsp;of&nbsp;Service</a></li><li itemprop="name"><a href="https://pulsegeek.com/site-map/" itemprop="url">HTML&nbsp;Sitemap</a></li><li itemprop="name"><a href="https://pulsegeek.com/rss.xml" itemprop="url" title="RSS 2.0 feed">RSS&nbsp;Feed</a></li><li itemprop="name"><a href="https://pulsegeek.com/atom.xml" itemprop="url" title="Atom 1.0 feed">Atom</a></li><li itemprop="name"><a href="https://pulsegeek.com/feed.json" itemprop="url" title="JSON Feed 1.1">JSON&nbsp;Feed</a></li></ul></nav><small style="display:block; margin-top:.75rem;"> © 2025 <span itemprop="name">PulseGeek</span>. All rights reserved. </small></footer><script type="module">
for (const code of document.querySelectorAll('figure.code-example pre code')) {
  if (code.dataset.lnDone) continue;
  const raw = code.innerHTML.replace(/\r/g,'');
  let lines = raw.split('\n');
  if (lines.length && lines[lines.length-1] === '') lines.pop();
  if (lines.length < 2) continue;
  code.innerHTML = lines.map(l => `<span>${l || '&#8203;'}</span>`).join('\n');
  code.dataset.lnDone = '1';
  code.closest('figure.code-example')?.classList.add('line-numbers');
}
</script></body></html> 