<!doctype html><html lang="en"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><title>Texture Compression Formats for Games: A Quick Catalog - PulseGeek</title><meta name="description" content="Understand how BC, ETC, ASTC, and PVRTC texture formats affect quality, size, and performance across platforms, plus when to use uncompressed fallbacks and key import settings." /><meta name="author" content="Ethan Palmer" /><link rel="canonical" href="https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog" /><link rel="apple-touch-icon" sizes="180x180" href="https://pulsegeek.com/apple-touch-icon.png" /><link rel="icon" type="image/png" sizes="32x32" href="https://pulsegeek.com/favicon-32x32.png" /><link rel="icon" type="image/png" sizes="16x16" href="https://pulsegeek.com/favicon-16x16.png" /><link rel="manifest" href="https://pulsegeek.com/site.webmanifest" /><link rel="alternate" type="application/rss+xml" title="PulseGeek RSS feed" href="https://pulsegeek.com/rss.xml" /><link rel="alternate" type="application/atom+xml" title="PulseGeek Atom feed" href="https://pulsegeek.com/atom.xml" /><link rel="alternate" type="application/feed+json" title="PulseGeek JSON feed" href="https://pulsegeek.com/feed.json" /><meta property="og:title" content="Texture Compression Formats for Games: A Quick Catalog" /><meta property="og:type" content="article" /><meta property="og:url" content="https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog" /><meta property="og:image" content="https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog/hero.webp" /><meta property="og:description" content="Understand how BC, ETC, ASTC, and PVRTC texture formats affect quality, size, and performance across platforms, plus when to use uncompressed fallbacks and key import settings." /><meta property="og:site_name" content="PulseGeek" /><meta property="og:locale" content="en_US" /><meta property="article:author" content="Ethan Palmer" /><meta property="article:publisher" content="PulseGeek" /><meta property="article:published_time" content="2025-12-02T16:17:00.0000000" /><meta property="article:modified_time" content="2025-10-31T13:00:02.6632299" /><meta property="article:section" content="Technology / Gaming / Game Engine Fundamentals" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:title" content="Texture Compression Formats for Games: A Quick Catalog" /><meta name="twitter:description" content="Understand how BC, ETC, ASTC, and PVRTC texture formats affect quality, size, and performance across platforms, plus when to use uncompressed fallbacks and key import settings." /><meta name="twitter:image" content="https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog/hero.webp" /><meta name="twitter:label1" content="Author" /><meta name="twitter:data1" content="Ethan Palmer" /><script type="application/ld+json"> {"@context":"https://schema.org","@graph":[{"@type":"Article","@id":"https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog#article","headline":"Texture Compression Formats for Games: A Quick Catalog","description":"Understand how BC, ETC, ASTC, and PVRTC texture formats affect quality, size, and performance across platforms, plus when to use uncompressed fallbacks and key import settings.","image":"https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog/hero.webp","author":{"@type":"Person","@id":"https://pulsegeek.com/authors/ethan-palmer#author","name":"Ethan Palmer","url":"https://pulsegeek.com/authors/ethan-palmer"},"publisher":{"@id":"https://pulsegeek.com#organization"},"datePublished":"2025-12-02T16:17:00-06:00","dateModified":"2025-10-31T13:00:02.6632299-05:00","mainEntityOfPage":"https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog","wordCount":"2414","inLanguage":"en-US"},{"@type":"Person","@id":"https://pulsegeek.com/authors/ethan-palmer#author","name":"Ethan Palmer","url":"https://pulsegeek.com/authors/ethan-palmer"},{"@type":"Organization","@id":"https://pulsegeek.com#organization","url":"https://pulsegeek.com","name":"PulseGeek","logo":{"@type":"ImageObject","url":"https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog/hero.webp"}},{"@type":"WebSite","@id":"https://pulsegeek.com#website","url":"https://pulsegeek.com","name":"PulseGeek"},{"@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Home","item":"https://pulsegeek.com"},{"@type":"ListItem","position":2,"name":"Technology / Gaming / Game Engine Fundamentals","item":"https://pulsegeek.com/technology / gaming / game engine fundamentals"},{"@type":"ListItem","position":3,"name":"Texture Compression Formats for Games: A Quick Catalog","item":"https://pulsegeek.com/articles/texture-compression-formats-for-games-a-quick-catalog"}]}]} </script><script async src="https://www.googletagmanager.com/gtag/js?id=G-KN2EBXS37E"></script><script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-KN2EBXS37E'); </script><link href="https://pulsegeek.com/css/pico.green.min.css" rel="stylesheet" /><link href="https://pulsegeek.com/css/site.css" rel="stylesheet" /></head><body><header class="site-header"><div class="container container-narrow"><nav><ul><li><a href="https://pulsegeek.com/" class="brand" aria-label="PulseGeek home"><img src="https://pulsegeek.com/images/logo.png" srcset="https://pulsegeek.com/images/logo.png 1x, https://pulsegeek.com/images/logo@2x.png 2x" alt="PulseGeek" width="308" height="64" class="brand-logo" decoding="async" fetchpriority="high" /></a></li></ul><ul><li><a href="https://pulsegeek.com/technology/">Technology</a></li></ul></nav></div></header><main class="container"><nav aria-label="Breadcrumb" class="breadcrumb"><ol><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><a href="https://pulsegeek.com/technology/" title="Technology">Technology</a></li><li class="breadcrumb-item" style="max-width: 180px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;"><span>Gaming</span></li></ol></nav><div class="share-buttons" aria-label="Share this article"><span>Share:</span><a class="share-btn x" href="https://twitter.com/intent/tweet?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Ftexture-compression-formats-for-games-a-quick-catalog&amp;text=Texture%20Compression%20Formats%20for%20Games%3A%20A%20Quick%20Catalog%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on X / Twitter"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M357.2 48L427.8 48 273.6 224.2 455 464 313 464 201.7 318.6 74.5 464 3.8 464 168.7 275.5-5.2 48 140.4 48 240.9 180.9 357.2 48zM332.4 421.8l39.1 0-252.4-333.8-42 0 255.3 333.8z"></path></svg></a><a class="share-btn fb" href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fpulsegeek.com%2Farticles%2Ftexture-compression-formats-for-games-a-quick-catalog" target="_blank" rel="noopener" aria-label="Share on Facebook"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M512 256C512 114.6 397.4 0 256 0S0 114.6 0 256C0 376 82.7 476.8 194.2 504.5l0-170.3-52.8 0 0-78.2 52.8 0 0-33.7c0-87.1 39.4-127.5 125-127.5 16.2 0 44.2 3.2 55.7 6.4l0 70.8c-6-.6-16.5-1-29.6-1-42 0-58.2 15.9-58.2 57.2l0 27.8 83.6 0-14.4 78.2-69.3 0 0 175.9C413.8 494.8 512 386.9 512 256z"></path></svg></a><a class="share-btn li" href="https://www.linkedin.com/sharing/share-offsite/?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Ftexture-compression-formats-for-games-a-quick-catalog" target="_blank" rel="noopener" aria-label="Share on LinkedIn"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 448 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M416 32L31.9 32C14.3 32 0 46.5 0 64.3L0 447.7C0 465.5 14.3 480 31.9 480L416 480c17.6 0 32-14.5 32-32.3l0-383.4C448 46.5 433.6 32 416 32zM135.4 416l-66.4 0 0-213.8 66.5 0 0 213.8-.1 0zM102.2 96a38.5 38.5 0 1 1 0 77 38.5 38.5 0 1 1 0-77zM384.3 416l-66.4 0 0-104c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9l0 105.8-66.4 0 0-213.8 63.7 0 0 29.2 .9 0c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9l0 117.2z"></path></svg></a><a class="share-btn rd" href="https://www.reddit.com/submit?url=https%3A%2F%2Fpulsegeek.com%2Farticles%2Ftexture-compression-formats-for-games-a-quick-catalog&amp;title=Texture%20Compression%20Formats%20for%20Games%3A%20A%20Quick%20Catalog%20-%20PulseGeek" target="_blank" rel="noopener" aria-label="Share on Reddit"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M0 256C0 114.6 114.6 0 256 0S512 114.6 512 256 397.4 512 256 512L37.1 512c-13.7 0-20.5-16.5-10.9-26.2L75 437C28.7 390.7 0 326.7 0 256zM349.6 153.6c23.6 0 42.7-19.1 42.7-42.7s-19.1-42.7-42.7-42.7c-20.6 0-37.8 14.6-41.8 34-34.5 3.7-61.4 33-61.4 68.4l0 .2c-37.5 1.6-71.8 12.3-99 29.1-10.1-7.8-22.8-12.5-36.5-12.5-33 0-59.8 26.8-59.8 59.8 0 24 14.1 44.6 34.4 54.1 2 69.4 77.6 125.2 170.6 125.2s168.7-55.9 170.6-125.3c20.2-9.6 34.1-30.2 34.1-54 0-33-26.8-59.8-59.8-59.8-13.7 0-26.3 4.6-36.4 12.4-27.4-17-62.1-27.7-100-29.1l0-.2c0-25.4 18.9-46.5 43.4-49.9 4.4 18.8 21.3 32.8 41.5 32.8l.1 .2zM177.1 246.9c16.7 0 29.5 17.6 28.5 39.3s-13.5 29.6-30.3 29.6-31.4-8.8-30.4-30.5 15.4-38.3 32.1-38.3l.1-.1zm190.1 38.3c1 21.7-13.7 30.5-30.4 30.5s-29.3-7.9-30.3-29.6 11.8-39.3 28.5-39.3 31.2 16.6 32.1 38.3l.1 .1zm-48.1 56.7c-10.3 24.6-34.6 41.9-63 41.9s-52.7-17.3-63-41.9c-1.2-2.9 .8-6.2 3.9-6.5 18.4-1.9 38.3-2.9 59.1-2.9s40.7 1 59.1 2.9c3.1 .3 5.1 3.6 3.9 6.5z"></path></svg></a><a class="share-btn email" href="mailto:?subject=Texture%20Compression%20Formats%20for%20Games%3A%20A%20Quick%20Catalog%20-%20PulseGeek&amp;body=https%3A%2F%2Fpulsegeek.com%2Farticles%2Ftexture-compression-formats-for-games-a-quick-catalog" aria-label="Share via email"><svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 512" width="20" height="20" aria-hidden="true" focusable="false"><path fill="currentColor" d="M61.4 64C27.5 64 0 91.5 0 125.4 0 126.3 0 127.1 .1 128L0 128 0 384c0 35.3 28.7 64 64 64l384 0c35.3 0 64-28.7 64-64l0-256-.1 0c0-.9 .1-1.7 .1-2.6 0-33.9-27.5-61.4-61.4-61.4L61.4 64zM464 192.3L464 384c0 8.8-7.2 16-16 16L64 400c-8.8 0-16-7.2-16-16l0-191.7 154.8 117.4c31.4 23.9 74.9 23.9 106.4 0L464 192.3zM48 125.4C48 118 54 112 61.4 112l389.2 0c7.4 0 13.4 6 13.4 13.4 0 4.2-2 8.2-5.3 10.7L280.2 271.5c-14.3 10.8-34.1 10.8-48.4 0L53.3 136.1c-3.3-2.5-5.3-6.5-5.3-10.7z"></path></svg></a></div><article><header style="text-align:center; margin-bottom:2rem;"><h1>Texture Compression Formats for Games: A Quick Catalog</h1><p><small> By <a href="https://pulsegeek.com/authors/ethan-palmer/">Ethan Palmer</a> &bull; Published <time datetime="2025-12-02T10:17:00-06:00" title="2025-12-02T10:17:00-06:00">December 2, 2025</time></small></p></header><p>Choosing texture compression formats for games is a balance between visual quality, GPU bandwidth, and memory footprint. This quick catalog focuses on practical choices across PC, console, and mobile, highlighting compression families, typical uses, and pitfalls. Items were selected based on widespread engine support, predictable artifact profiles, and platform availability. Each entry includes a concrete example and a tradeoff so you can evaluate formats under production constraints rather than theory alone.</p><section class="pg-summary-block pg-key-takeaways" role="note" aria-label="Key takeaways"><h2>Key takeaways</h2><ul><li>Match texture formats to platform GPUs to avoid silent fallbacks.</li><li>Opaque color favors BC1 or ETC2 to minimize memory without alpha.</li><li>Normal maps prefer two channel formats like BC5 for fidelity.</li><li>ASTC scales block size to tune quality versus size per asset.</li><li>Keep sRGB off for data textures and normal maps to avoid shifts.</li></ul></section><section class="pg-listicle-item"><h2 id="1-bc1-dxt1-for-opaque-albedo" data-topic="BC1" data-summary="Efficient opaque color without alpha">1. BC1 DXT1 for opaque albedo</h2><p>BC1, also known as DXT1, excels for opaque color textures thanks to a 4 bits per pixel footprint and fast sampling on desktop and console GPUs. For example, a 2048 by 2048 albedo drops from 16 MB uncompressed RGBA8 to 2 MB with BC1, often with acceptable banding only in smooth gradients. The <a class="glossary-term" href="https://pulsegeek.com/glossary/emulator-core/" data-tooltip="The component that emulates a specific system." tabindex="0">core</a> tradeoff is limited color precision and harsh artifacts around fine dithering or painterly strokes. If you include alpha, BC1 uses a one bit mask which yields crisp cutouts but jagged edges on soft antialiased foliage. Choose BC1 for opaque materials like walls, props, and terrain color layers where alpha is not needed, and favor dithered gradients or detail maps to hide block boundaries when art direction permits.</p><div class="pg-section-summary" data-for="#1-bc1-dxt1-for-opaque-albedo" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>BC1 cuts memory to 4 bpp but limits color precision.</li><li>Use on opaque albedo; avoid if soft alpha is required.</li></ul></div></section><section class="pg-listicle-item"><h2 id="2-bc3-dxt5-for-alpha-textures" data-topic="BC3" data-summary="Adds smooth alpha at 8 bpp">2. BC3 DXT5 for alpha textures</h2><p>BC3, or DXT5, is the go-to when you need smooth alpha with reasonable size, packing RGB like BC1 and a separate 8-bit alpha compressed block for 8 bits per pixel total. A common example is leaf cards or UI elements in 3D scenes, where soft transparency beats the binary mask of BC1. The cost is doubled memory compared to BC1 and slightly mushy gradients from alpha interpolation across the 4 by 4 block. For normal maps, avoid the traditional DXT5nm swizzle unless your engine lacks BC5 support, as it introduces cross-channel correlation artifacts. Pick BC3 for decals, foliage, and effects that depend on soft edges, and mitigate artifacts by trimming tiny transparent features, biasing alpha test thresholds, or snapping geometry to reduce tiny sub-pixel coverage changes.</p><div class="pg-section-summary" data-for="#2-bc3-dxt5-for-alpha-textures" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>BC3 provides smooth alpha at 8 bpp with block interpolation.</li><li>Prefer over BC1 when soft transparency is visually important.</li></ul></div></section><section class="pg-listicle-item"><h2 id="3-bc5-ati2-for-normal-maps" data-topic="BC5" data-summary="Two-channel precision for normals">3. BC5 ATI2 for normal maps</h2><p>BC5, sometimes labeled ATI2, compresses two independent channels which is ideal for tangent space normal maps storing X and Y while reconstructing Z in shader, preserving edge detail far better than color-oriented formats. On a rocky cliff normal at 2048 by 2048, BC5 maintains crisp microfacets and avoids color bleeding seen in BC3 or BC1, at the same 8 bpp as BC3. The tradeoff is losing a distinct alpha channel and increasing size compared to single-channel options. If your pipeline requires an opacity map, store it separately or pack it into a different texture. For engines that support it, mark the asset as normal data with linear sampling to avoid gamma shifts. For reference on broader asset <a class="glossary-term" href="https://pulsegeek.com/glossary/level-flow/" data-tooltip="The intended path and pacing through a level." tabindex="0">flow</a>, see the guide on a complete tour of rendering, physics, and optimization and how engines connect systems in responsive worlds by visiting <a href="https://pulsegeek.com/articles/game-engine-fundamentals-from-pixels-to-play-loops">how engines connect systems in responsive worlds</a>.</p><div class="pg-section-summary" data-for="#3-bc5-ati2-for-normal-maps" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>BC5 preserves normal detail by independently compressing two channels.</li><li>Store opacity elsewhere; keep sampling linear to avoid gamma shifts.</li></ul></div></section><section class="pg-listicle-item"><h2 id="4-bc7-high-fidelity-albedo-and-masks" data-topic="BC7" data-summary="Near-lossless quality at higher cost">4. BC7 high fidelity albedo and masks</h2><p>BC7 offers significantly improved quality over BC1 and BC3 by using multiple partition modes and higher precision, often approaching near-lossless results for albedo, ORM packs, or stylized art at 8 bpp. On coated metals or fabrics with smooth shading, BC7 reduces banding and preserves edges around decals that would smear under BC3. The tradeoff is slower encode and higher decode cost on some GPUs, plus larger sizes than BC1. On low-end hardware or bandwidth-limited platforms, BC7 can stall streaming more than simpler formats. Use BC7 selectively for hero assets, close-up first-person items, or UI textures where crispness impacts readability. For background props or distant scenery, you can often step down to BC1 or BC3 and spend the saved memory on broader environment variety documented in the complete guide to asset import and streaming via <a href="https://pulsegeek.com/articles/game-asset-pipeline-explained-from-dcc-to-runtime">asset import and streaming details</a>.</p><div class="pg-section-summary" data-for="#4-bc7-high-fidelity-albedo-and-masks" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>BC7 improves fidelity using flexible modes but costs more bandwidth.</li><li>Reserve for hero assets and readability-critical textures near camera.</li></ul></div></section><section class="pg-listicle-item"><h2 id="5-etc2-for-open-standards-on-mobile" data-topic="ETC2" data-summary="Default on GLES3 and Vulkan mobiles">5. ETC2 for open standards on mobile</h2><p>ETC2 is the baseline texture compression for OpenGL ES 3.0 and widely supported under <a class="glossary-term" href="https://pulsegeek.com/glossary/vulkan/" data-tooltip="A low-overhead graphics API often used in emulators." tabindex="0">Vulkan</a>, making it a safe default on many Android devices. For opaque color, ETC2 RGB delivers BC1-like quality at 4 bpp, while ETC2 RGBA adds punchthrough and full alpha variants at 8 bpp. On a grass terrain sheet, ETC2 RGB keeps tile variety crisp and maintains throughput on tilers. The compromise is less refined alpha quality compared to BC3 and limited advanced modes relative to BC7. Some older devices only support ETC1 without alpha, forcing multi-texture workarounds. Favor ETC2 when targeting a broad Android base and prefer ETC2 EAC variants for single-channel data like roughness or ambient occlusion to reduce size while retaining precision that matters for lighting stability.</p><div class="pg-section-summary" data-for="#5-etc2-for-open-standards-on-mobile" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>ETC2 is a broad mobile default with RGB and RGBA options.</li><li>Alpha quality trails BC3; check legacy devices for ETC1 limits.</li></ul></div></section><section class="pg-listicle-item"><h2 id="6-eac-r11-rg11-for-grayscale-data" data-topic="EAC" data-summary="Single-channel precision at small sizes">6. EAC R11 RG11 for grayscale data</h2><p>EAC R11 and RG11 target one or two channels respectively, providing better precision for data textures like roughness, height, or ambient occlusion at 4 or 8 bpp. On a parallax occlusion heightmap, EAC R11 retains micro ridges that would quantize in color-centric formats, improving specular stability during camera motion. The tradeoff is limited platform availability outside GLES3 and Vulkan ecosystems, and lack of built-in sRGB versions because these are meant for linear data. If you need paired masks, RG11 can pack roughness and metallic with acceptable precision, but be cautious about correlated error if you later blur or mip bias the pair differently. Choose EAC for Android targets where ETC2 is standard and keep your data space linear to avoid unwanted gamma corrections on lighting parameters.</p><div class="pg-section-summary" data-for="#6-eac-r11-rg11-for-grayscale-data" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>EAC variants compress linear data with good precision at low bpp.</li><li>Platform coverage is mobile centric; no sRGB versions by design.</li></ul></div></section><section class="pg-listicle-item"><h2 id="7-astc-scalable-blocks-for-fine-tuning" data-topic="ASTC" data-summary="Variable blocks tune size and quality">7. ASTC scalable blocks for fine tuning</h2><p>ASTC supports variable block sizes, from 4 by 4 up to 12 by 12, letting you trade quality for size per texture rather than per format. A 4K hero albedo might ship at 6 by 6 for crisp edges, while distant tilers use 10 by 10 to cut memory without visible loss, all at 8 to 12 bpp effective rates. The catch is encode time and device support that, while strong on newer iOS and many Android GPUs, is not universal on legacy hardware. Set format per platform and keep data in linear or sRGB as appropriate to avoid shifts. If your <a class="glossary-term" href="https://pulsegeek.com/glossary/build-pipeline/" data-tooltip="The automated process that creates deployable game builds." tabindex="0">build system</a> needs a per-platform rule, you can automate importer settings in engines like Unity to enforce ASTC on mobile while keeping BC on desktop.</p><figure class="code-example" data-language="csharp" data-caption="Unity editor script sets ASTC for Android and BC7 for Standalone." data-filename="SetTextureFormats.cs"><pre tabindex="0"><code class="language-csharp">using UnityEditor;
using UnityEngine;

public static class SetTextureFormats
{
    [MenuItem("Tools/Textures/Set Formats")]
    public static void SetFormats()
    {
        foreach (var guid in AssetDatabase.FindAssets("t:Texture2D"))
        {
            var path = AssetDatabase.GUIDToAssetPath(guid);
            var importer = (TextureImporter)AssetImporter.GetAtPath(path);
            if (importer == null) continue;

            var android = importer.GetPlatformTextureSettings("Android");
            android.overridden = true;
            android.format = TextureImporterFormat.ASTC_6x6;
            importer.SetPlatformTextureSettings(android);

            var standalone = importer.GetPlatformTextureSettings("Standalone");
            standalone.overridden = true;
            standalone.format = TextureImporterFormat.BC7;
            importer.SetPlatformTextureSettings(standalone);

            importer.SaveAndReimport();
        }
    }
}</code></pre><figcaption>Unity editor script sets ASTC for Android and BC7 for Standalone.</figcaption></figure></section><script type="application/ld+json">{ "@context": "https://schema.org", "@type": "SoftwareSourceCode", "programmingLanguage": "C#", "codeSampleType": "snippet", "about": "Automate <a class="glossary-term" href="https://pulsegeek.com/glossary/unity/" data-tooltip="A widely used game engine with strong tooling ecosystem." tabindex="0">Unity</a> texture import settings to choose ASTC on Android and BC7 on desktop.", "text": "using UnityEditor;\nusing UnityEngine;\n\npublic static class SetTextureFormats\n{\n [MenuItem(\"Tools/Textures/Set Formats\")]\n public static void SetFormats()\n {\n foreach (var guid in AssetDatabase.FindAssets(\"t:Texture2D\"))\n {\n var path = AssetDatabase.GUIDToAssetPath(guid);\n var importer = (TextureImporter)AssetImporter.GetAtPath(path);\n if (importer == null) continue;\n\n var android = importer.GetPlatformTextureSettings(\"Android\");\n android.overridden = true;\n android.format = TextureImporterFormat.ASTC_6x6;\n importer.SetPlatformTextureSettings(android);\n\n var standalone = importer.GetPlatformTextureSettings(\"Standalone\");\n standalone.overridden = true;\n standalone.format = TextureImporterFormat.BC7;\n importer.SetPlatformTextureSettings(standalone);\n\n importer.SaveAndReimport();\n }\n }\n}" }</script><div class="pg-section-summary" data-for="#7-astc-scalable-blocks-for-fine-tuning" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>ASTC tunes quality per texture by changing block dimensions.</li><li>Automate per-platform import rules to prevent accidental fallbacks.</li></ul></div><section class="pg-listicle-item"><h2 id="8-pvrtc-for-legacy-ios-support" data-topic="PVRTC" data-summary="Older iOS hardware compatibility">8. PVRTC for legacy iOS support</h2><p>PVRTC remains relevant for older iOS devices that lack ASTC, offering 2 bpp and 4 bpp modes with reasonable throughput. On a stylized skybox, PVRTC 4 bpp can look acceptable if you pre-filter gradients and avoid sharp checker patterns that reveal cross-shaped artifacts. The limitation is distinctive shimmering and blurriness on high-frequency details, making it a poor choice for text or UI textures. Because many modern Apple GPUs support ASTC, treat PVRTC as a fallback path and test on target devices to confirm that driver quality and decoder behavior match your assumptions. When you must ship PVRTC, reduce noise in source art and lean on mip bias to avoid temporal crawl during camera pans. For decisions around package layout and streaming impacts, see practical notes on import, compression, and packaging by exploring <a href="https://pulsegeek.com/articles/game-asset-pipeline-explained-from-dcc-to-runtime">packaging and streaming impacts</a>.</p><div class="pg-section-summary" data-for="#8-pvrtc-for-legacy-ios-support" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>PVRTC serves legacy iOS but blurs high-frequency content noticeably.</li><li>Prefer ASTC on modern devices; treat PVRTC as a fallback path.</li></ul></div></section><section class="pg-listicle-item"><h2 id="9-rgba8-when-uncompressed-is-safer" data-topic="Uncompressed" data-summary="Use for critical visual integrity">9. RGBA8 when uncompressed is safer</h2><p>Uncompressed RGBA8 is sometimes the correct choice when artifacts would undermine readability or when formats are unavailable on a slice of your audience. For instance, thin UI glyph atlases, gradient-heavy HUDs, and signed distance field text often look cleaner and render predictably as raw 32 bits per pixel. The obvious tradeoff is a large memory and bandwidth hit which multiplies across mips and variants, so restrict usage to small textures or those with minimal tiling. Set streaming priorities accordingly to prevent stalls during screen transitions. In content pipelines that bake multiple versions, you can selectively whitelist RGBA8 assets by tag to avoid accidental compression and keep analytics on their cost. If your open world uses heavy streaming, review how texture bandwidth and working set interact with terrain and audio by reading how to stream terrain, props, and audio for seamless traversal at <a href="https://pulsegeek.com/articles/content-streaming-for-open-worlds-flow-without-gaps">seamless traversal strategies</a>.</p><div class="pg-section-summary" data-for="#9-rgba8-when-uncompressed-is-safer" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>RGBA8 avoids artifacts for UI and text but costs significant memory.</li><li>Whitelist only critical assets and track the bandwidth overhead.</li></ul></div></section><section class="pg-listicle-item"><h2 id="10-srgb-vs-linear-settings-matter" data-topic="Color-space" data-summary="Correct data spaces prevent shifts">10. sRGB vs linear settings matter</h2><p>The sRGB toggle does not change the compression format but controls gamma-correct sampling, which is critical for color textures and harmful for data maps. For example, marking albedo as sRGB ensures proper filtering and blending, while leaving normal maps and roughness in linear preserves math used in lighting equations. The pitfall is silently misflagged imports that shift brightness or flatten specular response, which artists might overcompensate with content edits. Fix this at import with presets and <a class="glossary-term" href="https://pulsegeek.com/glossary/confidence-interval/" data-tooltip="A range around a forecast that shows the uncertainty of predictions, helping plan for best and worst cases." tabindex="0">CI</a> checks that verify expected color spaces per folder. Remember that some mobile APIs use implicit sRGB conversions when views are flagged, so align texture flags with sampler states. If you are evaluating format choices alongside import rules, it helps to compare format behavior and tooling around fidelity and size using a resource that explores fidelity, size, animation support, and tooling via format decision considerations.</p><div class="pg-section-summary" data-for="#10-srgb-vs-linear-settings-matter" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Use sRGB for color, linear for data to keep lighting correct.</li><li>Enforce import presets and CI checks to prevent misflags.</li></ul></div></section><section class="pg-listicle-item"><h2 id="11-alpha-handling-and-format-choices" data-topic="Alpha" data-summary="Pick alpha strategy per content">11. Alpha handling and format choices</h2><p>Alpha requirements drive format selection more than many teams expect, because smooth transparency raises costs and artifacts. Foliage atlases or smoke sheets benefit from BC3 or ETC2 RGBA to preserve soft edges, while masked hair cards using alpha test can use BC1 to stay at 4 bpp if thresholds are tuned. The tradeoff is in edge stability under motion; alpha test flicker can be reduced with temporal jitter and dithering patterns but may still be objectionable at distance. If the material also packs data like ambient occlusion in alpha, consider BC7 or separate masks to avoid cross-talk during compression. Always profile shader variants because alpha blending increases overdraw, and the extra bandwidth can erase gains from lighter formats described in general engine fundamentals available as a complete tour of rendering, physics, and scripting at <a href="https://pulsegeek.com/articles/game-engine-fundamentals-from-pixels-to-play-loops">a broad engine tour</a>.</p><div class="pg-section-summary" data-for="#11-alpha-handling-and-format-choices" role="note" aria-label="Section summary"><h3 class="summary-title">Section highlights</h3><ul class="mini"><li>Alpha needs often dictate BC3 or ETC2 RGBA over cheaper formats.</li><li>Tune thresholds or dither to stabilize edges and reduce flicker.</li></ul></div></section><table><thead><tr><th>Format</th><th>Typical use</th><th>Notes</th></tr></thead><tbody><tr><td>BC1</td><td>Opaque albedo</td><td>4 bpp, binary alpha only</td></tr><tr><td>BC3</td><td>Alpha textures</td><td>8 bpp, smooth transparency</td></tr><tr><td>BC5</td><td>Normal maps</td><td>Two channels, linear</td></tr><tr><td>BC7</td><td>High fidelity color</td><td>8 bpp, slower encode</td></tr><tr><td>ETC2</td><td>Mobile color</td><td>RGB 4 bpp, RGBA 8 bpp</td></tr><tr><td>ASTC</td><td>Scalable quality</td><td>Variable blocks, newer GPUs</td></tr><tr><td>PVRTC</td><td>Legacy iOS</td><td>Blurry on fine detail</td></tr><tr><td>RGBA8</td><td>UI, text</td><td>No artifacts, high cost</td></tr></tbody></table><section id="article-glossary" class="article-glossary" aria-labelledby="article-glossary-heading"><h2 id="article-glossary-heading">Key terms</h2><ul class="article-glossary-list"><li><a href="https://pulsegeek.com/glossary/build-pipeline/">Build Pipeline</a><span class="def"> — The automated process that creates deployable game builds.</span></li><li><a href="https://pulsegeek.com/glossary/compression/">Compression</a><span class="def"> — Reducing audio data size with perceptual or adaptive codecs.</span></li><li><a href="https://pulsegeek.com/glossary/confidence-interval/">Confidence Interval</a><span class="def"> — A range around a forecast that shows the uncertainty of predictions, helping plan for best and worst cases.</span></li><li><a href="https://pulsegeek.com/glossary/emulator-core/">Emulator Core</a><span class="def"> — The component that emulates a specific system.</span></li><li><a href="https://pulsegeek.com/glossary/level-flow/">Level Flow</a><span class="def"> — The intended path and pacing through a level.</span></li><li><a href="https://pulsegeek.com/glossary/unity/">Unity</a><span class="def"> — A widely used game engine with strong tooling ecosystem.</span></li><li><a href="https://pulsegeek.com/glossary/vulkan/">Vulkan</a><span class="def"> — A low-overhead graphics API often used in emulators.</span></li></ul></section><section id="faqs" class="pg-faq" aria-labelledby="faqs-heading"><h2 id="faqs-heading">Frequently asked questions</h2><div class="faq-item"><h3>Can I mix formats within one build?</h3><p>Yes. Engines support multiple formats in one build. Choose per asset and platform. Ensure your packaging and streaming systems keep formats supported on each target to avoid runtime decompression or large fallback textures.</p></div><div class="faq-item"><h3>Does compression affect mipmaps differently?</h3><p><a class="glossary-term" href="https://pulsegeek.com/glossary/compression/" data-tooltip="Reducing audio data size with perceptual or adaptive codecs." tabindex="0">Compression</a> applies to each mip level. Artifacts can become more pronounced at small mips, especially on PVRTC and ETC variants. Bias mip selection or sharpen selectively if distant views look muddy or shimmer.</p></div><div class="faq-item"><h3>Should normal maps use sRGB?</h3><p>No. Normal maps and other data textures should be linear. Enable sRGB for color textures like albedo to ensure gamma-correct sampling, but keep normals, roughness, and masks in linear space.</p></div><div class="faq-item"><h3>Is ASTC always better than BC formats?</h3><p>No. ASTC is flexible and often higher quality, but device support and encode time can limit usage. On desktop and console, BC formats are native and efficient. Choose what each platform decodes natively.</p></div><div class="faq-item"><h3>When should I avoid alpha altogether?</h3><p>Use opaque geometry when silhouettes are simple or can be modeled cheaply. Avoid alpha on large surfaces that cause heavy overdraw. For foliage and hair, alpha test is often cheaper than blending but may flicker.</p></div></section><script type="application/ld+json">{ "@context": "https://schema.org", "@type": "FAQPage", "mainEntity": [ { "@type": "Question", "name": "Can I mix formats within one build?", "acceptedAnswer": { "@type": "Answer", "text": "Yes. Engines support multiple formats in one build. Choose per asset and platform. Ensure your packaging and streaming systems keep formats supported on each target to avoid runtime decompression or large fallback textures." } }, { "@type": "Question", "name": "Does compression affect mipmaps differently?", "acceptedAnswer": { "@type": "Answer", "text": "Compression applies to each mip level. Artifacts can become more pronounced at small mips, especially on PVRTC and ETC variants. Bias mip selection or sharpen selectively if distant views look muddy or shimmer." } }, { "@type": "Question", "name": "Should normal maps use sRGB?", "acceptedAnswer": { "@type": "Answer", "text": "No. Normal maps and other data textures should be linear. Enable sRGB for color textures like albedo to ensure gamma-correct sampling, but keep normals, roughness, and masks in linear space." } }, { "@type": "Question", "name": "Is ASTC always better than BC formats?", "acceptedAnswer": { "@type": "Answer", "text": "No. ASTC is flexible and often higher quality, but device support and encode time can limit usage. On desktop and console, BC formats are native and efficient. Choose what each platform decodes natively." } }, { "@type": "Question", "name": "When should I avoid alpha altogether?", "acceptedAnswer": { "@type": "Answer", "text": "Use opaque geometry when silhouettes are simple or can be modeled cheaply. Avoid alpha on large surfaces that cause heavy overdraw. For foliage and hair, alpha test is often cheaper than blending but may flicker." } } ] }</script><h2 id="looking-ahead" data-topic="Next" data-summary="Plan tests and presets">Looking ahead</h2><p>Shift format selection from ad hoc decisions to repeatable presets backed by platform tests. Build a small matrix of target devices, then capture side-by-side captures for BC1, BC3, BC5, BC7, ETC2, ASTC, PVRTC, and RGBA8 across common materials like wood, skin, foliage, and UI. Track memory, load time, and artifact notes so future choices reference concrete evidence. Place import presets in source control, audit with CI, and revisit when engine or driver updates change decoders. For broader context on project-wide packaging choices, it helps to compare asset bundles and streaming strategies alongside compression to keep runtime smooth and patch sizes reasonable, which pairs well with understanding how engines turn inputs and data into responsive worlds via <a href="https://pulsegeek.com/articles/game-engine-fundamentals-from-pixels-to-play-loops">engine systems in context</a>.</p></article><aside class="related-articles" aria-label="Related articles"><h2>Related Articles</h2><ul><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/asset-bundles-vs-pak-files-packaging-tradeoffs">Asset Bundles vs Pak Files: Packaging Tradeoffs</a></h3><p>Compare asset bundles and pak files for game engines. Learn performance, patching, security, and workflow tradeoffs with examples and selection criteria.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/lod-setup-best-practices-detail-where-it-matters">LOD Setup Best Practices: Detail Where It Matters</a></h3><p>Learn practical LOD setup best practices for game assets, including screen-size metrics, crossfade transitions, impostors, and animation simplification to balance performance and visual quality.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/import-settings-for-textures-and-models-a-setup-guide">Import Settings for Textures and Models: A Setup Guide</a></h3><p>Configure import settings for textures and 3D models in Unity, Unreal, and Godot. Follow a practical plan, apply presets, validate results, and fix common pitfalls for clean, performant assets.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/build-pipeline-automation-for-game-projects">Build Pipeline Automation for Game Projects</a></h3><p>Learn how to plan, set up, and validate automated build pipelines for game projects with CI, asset cooking, and release packaging across engines.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/how-to-organize-game-project-folders-that-scale">How to Organize Game Project Folders That Scale</a></h3><p>Learn a practical folder strategy for game projects with naming rules, presets, automation scripts, and validation checks to prevent chaos as teams grow and platforms multiply.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/atlas-vs-array-textures-in-engines-choose-wisely">Atlas vs Array Textures in Engines: Choose Wisely</a></h3><p>Compare atlas and array textures in Unity, Unreal, and Godot. Learn batching impacts, filtering artifacts, memory behavior, and when each approach fits your game.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/audio-pipeline-basics-for-game-engines">Audio Pipeline Basics for Game Engines</a></h3><p>Learn core audio pipeline concepts for game engines, from import and compression to mixing, streaming, and latency. Choose formats, set budgets, and avoid pitfalls with practical decision frameworks.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/what-is-content-cooking-in-game-development">What Is Content Cooking in Game Development?</a></h3><p>Learn how content cooking transforms raw assets into engine-ready data for faster loads, smaller builds, and stable runtime behavior across platforms in modern game development.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/source-control-for-large-binary-assets-smart-tactics">Source Control for Large Binary Assets: Smart Tactics</a></h3><p>Learn practical tactics for managing large binary assets in source control, from Git LFS and locking to deterministic exports, sparse sync, and CI cooking.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/unity-addressables-vs-unreal-asset-manager">Unity Addressables vs Unreal Asset Manager</a></h3><p>Compare Unity Addressables and Unreal Asset Manager across referencing, packaging, async loading, memory, and versioning to choose the right content system for your game.</p></article></li><li><article class="related-card"><h3><a href="https://pulsegeek.com/articles/lightmap-uv-unwrapping-for-static-lighting">Lightmap UV Unwrapping for Static Lighting</a></h3><p>Learn how to unwrap lightmap UVs for clean static lighting in game engines. Plan scale, margins, and seams, then execute in Blender or DCC and validate for overlaps, bleeding, and leaks.</p></article></li></ul></aside></main><footer class="container" itemscope itemtype="https://schema.org/Organization"><hr /><nav aria-label="Footer navigation" itemscope itemtype="https://schema.org/SiteNavigationElement"><ul style="list-style:none; padding-left:0; margin:0; display:flex; flex-wrap:wrap; gap:.65rem;"><li itemprop="name"><a href="https://pulsegeek.com/about/" itemprop="url">About</a></li><li itemprop="name"><a href="https://pulsegeek.com/contact/" itemprop="url">Contact</a></li><li itemprop="name"><a href="https://pulsegeek.com/privacy/" itemprop="url">Privacy&nbsp;Policy</a></li><li itemprop="name"><a href="https://pulsegeek.com/terms/" itemprop="url">Terms&nbsp;of&nbsp;Service</a></li><li itemprop="name"><a href="https://pulsegeek.com/site-map/" itemprop="url">HTML&nbsp;Sitemap</a></li><li itemprop="name"><a href="https://pulsegeek.com/rss.xml" itemprop="url" title="RSS 2.0 feed">RSS&nbsp;Feed</a></li><li itemprop="name"><a href="https://pulsegeek.com/atom.xml" itemprop="url" title="Atom 1.0 feed">Atom</a></li><li itemprop="name"><a href="https://pulsegeek.com/feed.json" itemprop="url" title="JSON Feed 1.1">JSON&nbsp;Feed</a></li></ul></nav><small style="display:block; margin-top:.75rem;"> © 2025 <span itemprop="name">PulseGeek</span>. All rights reserved. </small></footer><script type="module">
for (const code of document.querySelectorAll('figure.code-example pre code')) {
  if (code.dataset.lnDone) continue;
  const raw = code.innerHTML.replace(/\r/g,'');
  let lines = raw.split('\n');
  if (lines.length && lines[lines.length-1] === '') lines.pop();
  if (lines.length < 2) continue;
  code.innerHTML = lines.map(l => `<span>${l || '&#8203;'}</span>`).join('\n');
  code.dataset.lnDone = '1';
  code.closest('figure.code-example')?.classList.add('line-numbers');
}
</script></body></html> 